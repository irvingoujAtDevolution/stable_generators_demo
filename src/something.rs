use std::borrow::BorrowMut;
use std::future::Future;
use std::sync::{Arc, Mutex};

use crate::client::{GeneratorHandler, NetworkClient};
use crate::generator::{self, Generator, YieldPoint};

// Data type our generator will yield back to the caller

pub enum Event {
    HttpRequest { url: String },
    PayloadLen(usize),
}

// Data type our generator will accept back at interruption points

#[derive(Debug)]
pub enum UserResponse {
    Payload(Vec<u8>),
    SomeValue(u32),
}

pub struct DoSomethingStruct<Y: Unpin + Send, R: Send> {
    client: Box<dyn NetworkClient<ResumeType = R, YieldType = Y>>,
}

impl DoSomethingStruct<Event, UserResponse> {
    pub fn new(
        client: Box<dyn NetworkClient<ResumeType = UserResponse, YieldType = Event>>,
    ) -> Self {
        Self {
            client: client,
        }
    }

    // The actual code is written pretty much as usual, expect itâ€™s actually a state
    // machine generated by the Rust compiler using async / await.
    // This function is an implementation detail, not exposed to the user.

    async fn do_something_impl(&mut self, url: String) -> u32 {
        // let user_response = self.yield_point.suspend(Event::HttpRequest { url }).await;
        // Now you can await without holding the MutexGuard
        let user_response = self.client.send(Event::HttpRequest { url }).await;

        let UserResponse::Payload(payload) = user_response else {
            panic!("not payload")
        };

        let length = payload.len();

        let user_response = self.do_something_nested_imple(length).await;

        let UserResponse::SomeValue(some_value) = user_response else {
            panic!("not some value")
        };

        return some_value + 10000;
    }

    async fn do_something_nested_imple(&mut self,length:usize) -> UserResponse{
        return self.client.send(Event::PayloadLen(length)).await;
    }

    // The function actually exposed to the user, simply wrapping our underlying "async" state machine

    pub fn do_something(&mut self, url: String) -> Generator<Event, UserResponse, u32>{
        let mut client_clone = self.client.box_clone();
        let generator = Generator::new(move |yield_point| async move {
            let mut new_self = DoSomethingStruct {
                client:client_clone.with_yield_point(yield_point)
            };
            new_self.do_something_impl(url).await
        });

        return generator;
    }

    pub fn do_something_another_way(&mut self,url:String,yield_point:YieldPoint<Event,UserResponse>) -> Generator<Event, UserResponse, u32>{
        let mut cleint_clone = self.client.box_clone();
        cleint_clone.add_yield_point(yield_point.clone());
        let generator = Generator::new_with_yield_point(yield_point.clone(),async move{
            let mut new_self = DoSomethingStruct {
                client: cleint_clone,
            };
            new_self.do_something_impl(url).await
        });
        generator
    }

    pub fn do_something_another_way_with_original_client(&mut self,url:String,yield_point:YieldPoint<Event,UserResponse>) -> Generator<Event, UserResponse, u32>{
        let generator = Generator::new_with_yield_point(yield_point.clone(),async move{
            let mut new_self = DoSomethingStruct {
                client: self.client.box_clone(),
            };
            new_self.do_something_impl(url).await
        });
        generator
    }

    

}
